"use strict";(self.webpackChunkvrctxl=self.webpackChunkvrctxl||[]).push([[9300],{8462:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var i=n(5893),s=n(1151);const a={sidebar_position:1},o="Digest Data Validator",r={id:"access-txl/validation/digest-data-validator",title:"Digest Data Validator",description:"The Digest Data Validator is a Data Validator implementation that uses a digest (such as an MD5 or SHA1 hash) included",source:"@site/docs/access-txl/validation/digest-data-validator.md",sourceDirName:"access-txl/validation",slug:"/access-txl/validation/digest-data-validator",permalink:"/Docs/docs/access-txl/validation/digest-data-validator",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docs",previous:{title:"Data Validator",permalink:"/Docs/docs/access-txl/validation/data-validator"},next:{title:"Changelog",permalink:"/Docs/docs/access-txl/changelog"}},d={},h=[{value:"Creating a Digest",id:"creating-a-digest",level:2},{value:"Hash Functions",id:"hash-functions",level:3},{value:"Hashing Strategies",id:"hashing-strategies",level:3},{value:"Secret Key",id:"secret-key",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"digest-data-validator",children:"Digest Data Validator"}),"\n",(0,i.jsx)(t.p,{children:"The Digest Data Validator is a Data Validator implementation that uses a digest (such as an MD5 or SHA1 hash) included\nwith the data to validate that the data itself has not been tampered with.  The digest is expected to be prepended to\nthe data, which is isolated in the pre-validate step and discarded by the transform.  The data is hashed with a specified\nhash function, hash strategy, and secret key.  If the result doesn't match the digest value, the data is assumed to be\ntampered with and the validation fails."}),"\n",(0,i.jsx)(t.h2,{id:"creating-a-digest",children:"Creating a Digest"}),"\n",(0,i.jsx)(t.p,{children:"The digest that's included with the data needs to be generated with:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"A compatible hash function"}),"\n",(0,i.jsx)(t.li,{children:"A secret key"}),"\n",(0,i.jsx)(t.li,{children:"A strategy for how the key is hashed with the data."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The digest should be ",(0,i.jsx)(t.strong,{children:"prepended"})," to the data, as the very first part of th string, with space or newline characters\noptionally following it."]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsxs)(t.p,{children:["Example of ",(0,i.jsx)(t.code,{children:"Newline"})," data for a ",(0,i.jsx)(t.strong,{children:"Remote Whitelist"})," including a SHA1 digest"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"a01afb47df07f98b8fc4f4e7e7ec7ba185d58f2e\nTexelsaur\ngplord\ncnlohr\n"})})]}),"\n",(0,i.jsx)(t.h3,{id:"hash-functions",children:"Hash Functions"}),"\n",(0,i.jsxs)(t.p,{children:["Hash functions are supported via the included ",(0,i.jsx)(t.strong,{children:"UdonHashLib"})," class by ",(0,i.jsx)(t.a,{href:"https://github.com/Gorialis",children:"Gorialis"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"UdonHashLib supports the following has functions:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"MD5"}),"\n",(0,i.jsx)(t.li,{children:"SHA1, SHA224, SHA256, SHA384, SHA512"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The validator needs to reference an object with the UdonHashLib script."}),"\n",(0,i.jsxs)(t.p,{children:["Udon is not efficient at cryptographic hashing, so the more secure SHA variants are going to be slower and may lock up\nthe player for a short time, particularly if the data being hashed is large, as in a large Patreon list.  ",(0,i.jsx)(t.strong,{children:"SHA1"})," should\nbe reasonable for most cases."]}),"\n",(0,i.jsx)(t.h3,{id:"hashing-strategies",children:"Hashing Strategies"}),"\n",(0,i.jsx)(t.p,{children:"Hashing strategy refers to how a secret key is combined with the data before hashing it.  The following strategies are supported:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Prefix Key"})," - Append the data string to the key string"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Postfix Key"})," - Append the key string to the data string"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Prefix Postfix Key"})," - Sandwich the data string between two copies of the ket string"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"HMAC"})," - For the SHA hash functions only"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"HMAC"})," strategy involves a more sophisticated process of transforming the key, hashing it with the data, and hashing the result.\nIt's considered more secure than simple appending of key and data strings.  Most cryptographic libraries should supply dedicated HMAC\nhashing functions.  HMAC may be up to 2x slower than other strategies because it performs two hashing passes, but only one of them\nis performed on the full data length."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.strong,{children:"Prefix Postfix"})," stategy is better than prefix or postfix alone."]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsxs)(t.p,{children:["Example of ",(0,i.jsx)(t.code,{children:"Newline"})," data combined with the secret key ",(0,i.jsx)(t.code,{children:"txl123"})," using the ",(0,i.jsx)(t.strong,{children:"Prefix Postfix Key"})," strategy.\nNote that there is no additional whitespace between key and data."]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"txl123Texelsaur\ngplord\ncnlohrtxl123\n"})})]}),"\n",(0,i.jsx)(t.h3,{id:"secret-key",children:"Secret Key"}),"\n",(0,i.jsx)(t.p,{children:"A secret key is a string known by the creator of the data and the scene, but not anyone else.  It's necessary to prevent\na would-be tamperer to generate a new valid digest for the modified data."}),"\n",(0,i.jsx)(t.admonition,{title:"Key Security",type:"warning",children:(0,i.jsx)(t.p,{children:"It's not possible to keep a key completely secure on the client.  Any player who is able to rip the world and unpack it\ncan eventually root out the key, even if steps have been taken to obfuscate it.  How much effort you want to force an\nattacker to spend finding the key is up to you, but you cannot count on your system to be completely secure."})}),"\n",(0,i.jsxs)(t.p,{children:["To give the world developer flexibility in how to store their secret key, it needs to be provided from an udon component\nthat extends the ",(0,i.jsx)(t.strong,{children:"DataValidatorKey"})," class."]}),"\n",(0,i.jsx)(t.p,{children:"An implementation is included that serializes the key as a field on the script.  This is convenient, but probably the least\nsecure way to store a key in your scene.  This may be discoverable with the right client tools without needing to fully\nrip the world open.  However, if you only care about making the process annoying, this might be good enough."}),"\n",(0,i.jsx)(t.p,{children:"A variant of the Data Validator prefab is included with the serialized key provider by default."})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var i=n(7294);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);